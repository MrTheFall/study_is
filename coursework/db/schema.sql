begin;

create table if not exists clients (
    id                integer generated by default as identity primary key,
    name              varchar(255)        not null,
    phone             varchar(64)         not null,
    email             varchar(255)        not null,
    password_hash     text                not null,
    default_address   text,
    registered_at     date                not null default current_date,
    loyalty_points    integer             not null default 0,
    constraint chk_clients_loyalty_nonneg check (loyalty_points >= 0),
    constraint uq_clients_email unique (email),
    constraint uq_clients_phone unique (phone)
);

create table if not exists roles (
    id            integer generated by default as identity primary key,
    name          varchar(128) not null,
    permissions   text,
    constraint uq_roles_name unique (name)
);

create table if not exists employees (
    id              integer generated by default as identity primary key,
    full_name       varchar(255)    not null,
    login           varchar(128)    not null,
    password_hash   text            not null,
    role_id         integer         not null,
    salary          numeric(14,2)   not null default 0,
    contact_phone   varchar(64),
    hired_at        timestamp       not null default now(),
    constraint chk_employees_salary_nonneg check (salary >= 0),
    constraint uq_employees_login unique (login),
    constraint fk_employees_role
        foreign key (role_id) references roles(id)
        on delete restrict
);
create index if not exists idx_employees_role_id on employees(role_id);

create table if not exists shifts (
    id          integer generated by default as identity primary key,
    shift_date  date        not null,
    start_time  time        not null,
    end_time    time        not null,
    note        varchar(255),
    constraint chk_shifts_time_order check (start_time < end_time)
);

create table if not exists employee_shifts (
    id           integer generated by default as identity primary key,
    employee_id  integer     not null,
    shift_id     integer     not null,
    status       varchar(64),
    constraint fk_employee_shifts_employee
        foreign key (employee_id) references employees(id)
        on delete cascade,
    constraint fk_employee_shifts_shift
        foreign key (shift_id) references shifts(id)
        on delete cascade,
    constraint uq_employee_shifts_unique unique (employee_id, shift_id)
);
create index if not exists idx_employee_shifts_employee_id on employee_shifts(employee_id);
create index if not exists idx_employee_shifts_shift_id on employee_shifts(shift_id);

create table if not exists couriers (
    id            integer generated by default as identity primary key,
    name          varchar(255) not null,
    phone         varchar(64)  not null,
    vehicle_info  varchar(255),
    constraint uq_couriers_phone unique (phone)
);

create table if not exists menu_items (
    id                  integer generated by default as identity primary key,
    name                varchar(255)      not null,
    description         text,
    price               numeric(14,2)     not null,
    available           boolean           not null default true,
    prep_time_minutes   integer           not null default 0,
    constraint chk_menu_items_price_nonneg check (price >= 0),
    constraint chk_menu_items_prep_nonneg  check (prep_time_minutes >= 0)
);

create table if not exists recipes (
    id                integer generated by default as identity primary key,
    menu_item_id      integer       not null,
    name              varchar(255)  not null,
    description       text,
    preparation_time  integer       not null default 0,
    servings          integer       not null default 1,
    instructions      text,
    constraint chk_recipes_prep_nonneg check (preparation_time >= 0),
    constraint chk_recipes_servings_pos check (servings > 0),
    constraint fk_recipes_menu_item
        foreign key (menu_item_id) references menu_items(id)
        on delete cascade,
    constraint uq_recipes_menu_item unique (menu_item_id)
);
create index if not exists idx_recipes_menu_item_id on recipes(menu_item_id);

create table if not exists ingredients (
    id               integer generated by default as identity primary key,
    name             varchar(255)   not null,
    unit             varchar(32)    not null,
    cost_per_unit    numeric(14,4)  not null default 0,
    min_threshold    numeric(14,3)  not null default 0,
    constraint chk_ingredients_cost_nonneg check (cost_per_unit >= 0),
    constraint chk_ingredients_threshold_nonneg check (min_threshold >= 0),
    constraint uq_ingredients_name unique (name)
);

create table if not exists ingredient_usages (
    id                 integer generated by default as identity primary key,
    recipe_id          integer       not null,
    ingredient_id      integer       not null,
    quantity_required  numeric(14,3) not null,
    unit_note          varchar(64),
    constraint chk_ing_usage_qty_pos check (quantity_required > 0),
    constraint fk_ing_usage_recipe
        foreign key (recipe_id) references recipes(id)
        on delete cascade,
    constraint fk_ing_usage_ingredient
        foreign key (ingredient_id) references ingredients(id)
        on delete restrict
);
create index if not exists idx_ingredient_usages_recipe_id on ingredient_usages(recipe_id);
create index if not exists idx_ingredient_usages_ingredient_id on ingredient_usages(ingredient_id);

create table if not exists inventory_records (
    id            integer generated by default as identity primary key,
    ingredient_id integer        not null,
    quantity      numeric(14,3)  not null default 0,
    last_updated  timestamp      not null default now(),
    constraint chk_inventory_qty_nonneg check (quantity >= 0),
    constraint fk_inventory_ingredient
        foreign key (ingredient_id) references ingredients(id)
        on delete cascade
);
create index if not exists idx_inventory_records_ingredient_id on inventory_records(ingredient_id);

create table if not exists orders (
    id                integer generated by default as identity primary key,
    client_id         integer       not null,
    type              varchar(32)   not null, -- dine_in / takeout / delivery
    status            varchar(32)   not null, -- pending / confirmed / preparing / ready / delivering / delivered / completed / cancelled
    created_at        timestamp     not null default now(),
    updated_at        timestamp     not null default now(),
    total_amount      numeric(14,2) not null default 0,
    courier_id        integer,
    delivered_at      timestamp,
    delivery_address  text,
    constraint chk_orders_amount_nonneg check (total_amount >= 0),
    constraint chk_orders_type_enum check (lower(type) in ('dine_in','takeout','delivery')),
    constraint chk_orders_status_enum check (lower(status) in ('pending','confirmed','preparing','ready','delivering','delivered','completed','cancelled')),
    constraint chk_orders_delivery_address_required check (
        (lower(type) <> 'delivery') or (delivery_address is not null and length(trim(delivery_address)) > 0)
    ),
    constraint chk_orders_courier_for_non_delivery check (
        (lower(type) = 'delivery') or (courier_id is null)
    ),
    constraint chk_orders_delivered_at_logic check (
        delivered_at is null or lower(status) in ('delivered','completed')
    ),
    constraint fk_orders_client
        foreign key (client_id) references clients(id)
        on delete restrict,
    constraint fk_orders_courier
        foreign key (courier_id) references couriers(id)
        on delete set null
);
create index if not exists idx_orders_client_id on orders(client_id);
create index if not exists idx_orders_courier_id on orders(courier_id);
create index if not exists idx_orders_status on orders(status);

create table if not exists order_items (
    id            integer generated by default as identity primary key,
    order_id      integer        not null,
    menu_item_id  integer        not null,
    quantity      integer        not null,
    unit_price    numeric(14,2)  not null,
    total_price   numeric(14,2)  generated always as (unit_price * quantity) stored,
    note          text,
    constraint chk_order_items_qty_pos check (quantity > 0),
    constraint chk_order_items_price_nonneg check (unit_price >= 0),
    constraint fk_order_items_order
        foreign key (order_id) references orders(id)
        on delete cascade,
    constraint fk_order_items_menu_item
        foreign key (menu_item_id) references menu_items(id)
        on delete restrict
);
create index if not exists idx_order_items_order_id on order_items(order_id);
create index if not exists idx_order_items_menu_item_id on order_items(menu_item_id);

create table if not exists payments (
    id         integer generated by default as identity primary key,
    order_id   integer        not null,
    method     varchar(32)    not null, -- cash / card / online
    amount     numeric(14,2)  not null,
    paid_at    timestamp,
    success    boolean        not null default false,
    constraint chk_payments_amount_nonneg check (amount >= 0),
    constraint chk_payments_method_enum check (lower(method) in ('cash','card','online')),
    constraint fk_payments_order
        foreign key (order_id) references orders(id)
        on delete cascade
);
create index if not exists idx_payments_order_id on payments(order_id);
create unique index if not exists uq_payments_order on payments(order_id);

create table if not exists reviews (
    id          integer generated by default as identity primary key,
    order_id    integer     not null,
    client_id   integer     not null,
    rating      integer     not null,
    comment     text,
    created_at  timestamp   not null default now(),
    constraint chk_reviews_rating_range check (rating between 1 and 5),
    constraint fk_reviews_order
        foreign key (order_id) references orders(id)
        on delete cascade,
    constraint fk_reviews_client
        foreign key (client_id) references clients(id)
        on delete restrict
);
create index if not exists idx_reviews_client_id on reviews(client_id);
create index if not exists idx_reviews_order_id on reviews(order_id);

create unique index if not exists uq_reviews_order_client on reviews(order_id, client_id);

-- Триггеры и функции целостности

create or replace function trg_orders_set_updated_at()
returns trigger language plpgsql as $$
begin
    new.updated_at := now();
    return new;
end;$$;

drop trigger if exists set_updated_at on orders;
create trigger set_updated_at
before update on orders
for each row execute function trg_orders_set_updated_at();

create or replace function recalc_order_total_and_validate(p_order_id integer)
returns void language plpgsql as $$
declare
    v_total   numeric(14,2);
    v_amount  numeric(14,2);
    v_success boolean;
begin
    select coalesce(sum(oi.unit_price * oi.quantity), 0)
      into v_total
      from order_items oi
     where oi.order_id = p_order_id;

    update orders
       set total_amount = v_total,
           updated_at   = now()
     where id = p_order_id;

    select p.amount, p.success
      into v_amount, v_success
      from payments p
     where p.order_id = p_order_id;

    if coalesce(v_success, false) then
        if coalesce(v_amount, 0) <> v_total then
            raise exception 'Payment amount (%.2f) must equal order total (%.2f) for order %', v_amount, v_total, p_order_id
                using errcode = '23514';
        end if;
    end if;
end;$$;

create or replace function trg_order_items_default_price()
returns trigger language plpgsql as $$
begin
    if new.unit_price is null then
        select mi.price into new.unit_price from menu_items mi where mi.id = new.menu_item_id;
    end if;
    return new;
end;$$;

drop trigger if exists order_items_default_price on order_items;
create trigger order_items_default_price
before insert on order_items
for each row execute function trg_order_items_default_price();

create or replace function trg_order_items_recalc_order()
returns trigger language plpgsql as $$
begin
    if tg_op = 'DELETE' then
        perform recalc_order_total_and_validate(old.order_id);
    else
        perform recalc_order_total_and_validate(new.order_id);
    end if;
    return null;
end;$$;

drop trigger if exists order_items_recalc_after_ins on order_items;
drop trigger if exists order_items_recalc_after_upd on order_items;
drop trigger if exists order_items_recalc_after_del on order_items;

create trigger order_items_recalc_after_ins
after insert on order_items
for each row execute function trg_order_items_recalc_order();

create trigger order_items_recalc_after_upd
after update on order_items
for each row execute function trg_order_items_recalc_order();

create trigger order_items_recalc_after_del
after delete on order_items
for each row execute function trg_order_items_recalc_order();

create or replace function trg_payments_validate_and_bump()
returns trigger language plpgsql as $$
begin
    if tg_op = 'DELETE' then
        perform recalc_order_total_and_validate(old.order_id);
    else
        perform recalc_order_total_and_validate(new.order_id);
    end if;
    return null;
end;$$;

drop trigger if exists payments_validate_after_ins on payments;
drop trigger if exists payments_validate_after_upd on payments;
drop trigger if exists payments_validate_after_del on payments;

create trigger payments_validate_after_ins
after insert on payments
for each row execute function trg_payments_validate_and_bump();

create trigger payments_validate_after_upd
after update of amount, success on payments
for each row execute function trg_payments_validate_and_bump();

create trigger payments_validate_after_del
after delete on payments
for each row execute function trg_payments_validate_and_bump();

create or replace function trg_payments_set_paid_at()
returns trigger language plpgsql as $$
begin
    if new.success = true and new.paid_at is null then
        new.paid_at := now();
    end if;
    return new;
end;$$;

drop trigger if exists payments_set_paid_at on payments;
create trigger payments_set_paid_at
before insert or update of success, paid_at on payments
for each row execute function trg_payments_set_paid_at();

create or replace function trg_inventory_touch()
returns trigger language plpgsql as $$
begin
    new.last_updated := now();
    return new;
end;$$;

drop trigger if exists inventory_touch on inventory_records;
create trigger inventory_touch
before update on inventory_records
for each row execute function trg_inventory_touch();

create or replace function trg_employee_shifts_no_overlap()
returns trigger language plpgsql as $$
declare
    s_new shifts%rowtype;
    v_exists boolean;
begin
    select * into s_new from shifts where id = new.shift_id;
    if s_new.id is null then
        raise exception 'Shift % not found', new.shift_id using errcode = '23503';
    end if;

    select exists (
        select 1
          from employee_shifts es
          join shifts s on s.id = es.shift_id
         where es.employee_id = new.employee_id
           and es.id <> coalesce(new.id, -1)
           and s.shift_date = s_new.shift_date
           and not (s.end_time <= s_new.start_time or s.start_time >= s_new.end_time)
    ) into v_exists;

    if v_exists then
        raise exception 'Employee % already scheduled for overlapping shift on %', new.employee_id, s_new.shift_date using errcode = '23514';
    end if;
    return new;
end;$$;

drop trigger if exists employee_shifts_no_overlap on employee_shifts;
create trigger employee_shifts_no_overlap
before insert or update on employee_shifts
for each row execute function trg_employee_shifts_no_overlap();

commit;
